<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>学生ルーレット + 効果音</title>
<style>
  body { font-family: sans-serif; text-align: center; background: #f4f4f4; }
  #roulette { font-size: 48px; margin: 40px 0; height: 60px; }
  button{margin:4px;padding:4px 10px;}

  .highlight {
    color: crimson;
    font-weight: bold;
    font-size: 1.3em;
    animation: shake 0.3s;
  }

  @keyframes shake {
    0%   { transform: translateX(0); }
    25%  { transform: translateX(-5px); }
    50%  { transform: translateX(5px); }
    75%  { transform: translateX(-5px); }
    100% { transform: translateX(0); }
  }
</style>
</head>
<body>
<h1>学生ルーレット + 効果音</h1>

<div id="class-buttons" class="class-buttons"></div>
<button onclick="window.open('https://docs.google.com/spreadsheets/d/1b76BPsMlb_WSWeAAEjKnDlz4TOf4OJZZA_RnXDSf4cA/edit', '_blank')">
  名簿を編集
</button>
<button id="toggle-duplicate" onclick="toggleDuplicate()">重複なし</button>

<div id="roulette">ルーレット中...</div>
<button onclick="startRoulette()">▶ スタート</button>

<div class="history">
  <h3>選ばれた学生:</h3>
  <ul id="history"></ul>
</div>

<script>
let studentsByClass = {};
let currentClass = "";
let currentList = [];
let allowDuplicates = false;
let spinning = false;
let currentIndex = 0;
let audio;
let rollCount = 0;

const isGitHub = location.hostname.includes("github.io");
const dataUrl =
  "https://script.google.com/macros/s/AKfycbwXnWol3-h3-ARAUzw88NAnC7yKMILn_WzNiNrxDz-0imv3mSBoSvYw7n5BwP7r0Cxcpw/exec";
const baseUrl = isGitHub
  ? "https://jinpati2025.github.io/roulette01/"
  : "./";

const soundFiles = [
  "01_roll_basic.mp3","02_roll_impact.mp3","03_roll_shiden.mp3",
  "04_fanfare_cheer.mp3","05_fanfare_pokupoku.mp3",
  "06_voice_oujo.mp3","07_voice_doragon.mp3"
];

/* --- 名簿データ取得してクラスボタン生成 --- */
fetch(dataUrl)
  .then(res => res.json())
  .then(data => {
    console.log("名簿取得成功:", data);
    studentsByClass = data;
    const keys = Object.keys(data);
    if (keys.length) {
      currentClass = keys[0];
      currentList  = [...data[currentClass]];
    }
    renderClassButtons();
  })
  .catch(err => {
    console.error("名簿取得失敗:", err);
    alert("名簿が読み込めませんでした。GASの公開設定やURLを確認してください。");
  });

/* 重複あり／なし トグル */
function toggleDuplicate(){
  allowDuplicates = !allowDuplicates;
  const btn = document.getElementById("toggle-duplicate");
  btn.textContent = allowDuplicates ? "重複あり" : "重複なし";
}

/* クラスボタン生成 */
function renderClassButtons(){
  const box = document.getElementById("class-buttons");
  box.innerHTML = "";
  Object.keys(studentsByClass).forEach(k => {
    const btn = document.createElement("button");
    btn.textContent = k;
    btn.onclick = () => selectClass(k);
    box.appendChild(btn);
  });
}

/* クラス切り替え */
function selectClass(k){
  currentClass = k;
  currentList  = [...(studentsByClass[k] || [])];
  document.getElementById("history").innerHTML = "";
  document.getElementById("roulette").textContent = "名前がここに表示されます";
}

/* ★ルーレット本体 */
function startRoulette(){
  if (spinning) return;
  if (!currentList.length) {
    alert("名簿がありません");
    return;
  }
  spinning = true;

  // 効果音をランダムに選択
  const sound = soundFiles[Math.floor(Math.random() * soundFiles.length)];
  audio = new Audio(baseUrl + sound);

  audio.addEventListener("loadedmetadata", () => {
    if (!currentList.length) {
      alert("名簿が空です");
      spinning = false;
      return;
    }

    // ★最終的に当たる位置をランダムに決める
    const finalIndex = Math.floor(Math.random() * currentList.length);

    const duration   = audio.duration;
    const totalSteps = 38;

    // ★回転時間（少し短め）
    const spinTime     = Math.max(duration - 1, 1.5);
    const baseInterval = (spinTime * 1000) / (totalSteps + 2);

    audio.play();

    let spins = 0;

    const step = () => {
      if (spins >= totalSteps) {
        // 回転終了 → 結果演出へ
        setTimeout(() => {
          runResultSequence(finalIndex);
        }, 200);
        return;
      }

      // ぐるぐる表示部分
      document.getElementById("roulette").textContent =
        currentList[currentIndex];
      currentIndex = (currentIndex + 1) % currentList.length;
      spins++;

      let delay = baseInterval;
      if (spins > totalSteps * 0.7) {
        delay *= 1.6;
      } else if (spins > totalSteps * 0.5) {
        delay *= 1.3;
      }

      setTimeout(step, delay);
    };

    step();
  });
}

/* ★結果演出の分岐（直球／弾き飛ばす／はじき返す） */
function runResultSequence(finalIndex){
  const el  = document.getElementById("roulette");
  const len = currentList.length;

  if (!len) {
    finishSelection(finalIndex, "normal");
    return;
  }

  // 前の人（A）と当たりの人（B）を決定
  const prevIdx = (finalIndex - 1 + len) % len;  // 前の人
  const nameA   = currentList[prevIdx];
  const nameB   = currentList[finalIndex];

  // デフォルトは直球
  let mode = "normal";

  if (len >= 2) {
    const r = Math.random();
    // 10%：はじき返す、20%：弾き飛ばす、残りは直球
    if (r < 0.10) {
      mode = "counter"; // A が勝つ
    } else if (r < 0.30) {
      mode = "attack";  // B が勝つ（A を弾き飛ばす）
    }
  }

  // まずは 3パターン共通の導入演出（A → B）
  playIntro(el, nameA, nameB, () => {
    if (mode === "normal" || len < 2) {
      // 直球パターン
      playNormalFinish(el, finalIndex);
    } else if (mode === "attack") {
      // 前の人 A を弾き飛ばして B が勝つ
      playAttackFinish(el, prevIdx, finalIndex);
    } else { // counter
      // B が攻めてくるが、A がはじき返す
      playCounterFinish(el, prevIdx, finalIndex);
    }
  });
}

/* ★導入演出（Aで決まりかけ → Bも候補に見える） */
function playIntro(el, nameA, nameB, done){
  // ① A が一瞬「当たりっぽく」光る
  el.textContent = nameA;
  el.animate(
    [
      { transform:"scale(1)"   },
      { transform:"scale(1.15)" },
      { transform:"scale(1)"   }
    ],
    { duration:260, easing:"ease-out" }
  );

  setTimeout(() => {
    // ② B にもチャンスがありそうに見せる
    el.textContent = nameB;
    el.animate(
      [
        { transform:"scale(1)"   },
        { transform:"scale(1.12)" },
        { transform:"scale(1)"   }
      ],
      { duration:260, easing:"ease-out" }
    );
    setTimeout(done, 270);
  }, 270);
}

/* ★直球パターンの決定演出（軽い演出をここに集約） */
function playNormalFinish(el, selIdx){
  const selected = currentList[selIdx];

  el.textContent = selected;
  el.animate(
    [
      { transform:"scale(1)"   },
      { transform:"scale(1.2)" },
      { transform:"scale(1)"   }
    ],
    { duration:300, easing:"ease-out" }
  );

  setTimeout(() => {
    finishSelection(selIdx, "normal");
  }, 310);
}

/* ★B が A を弾き飛ばして勝つパターン（20%） */
function playAttackFinish(el, prevIdx, finalIdx){
  const nameA = currentList[prevIdx];    // ほぼ当たりだった前の人
  const nameB = currentList[finalIdx];   // 本当の当たり（次の人）

  // 小競り合いっぽく A がちょっと粘る
  el.textContent = nameA;
  el.animate(
    [
      { transform:"translateX(0)"   },
      { transform:"translateX(-10px)" },
      { transform:"translateX(0)"   }
    ],
    { duration:220, easing:"ease-out" }
  );

  setTimeout(() => {
    // B が横から突撃してくる
    el.textContent = nameB;
    el.animate(
      [
        { transform:"translateX(-80px)", opacity:0 },
        { transform:"translateX(0)",     opacity:1 }
      ],
      { duration:230, easing:"ease-out" }
    );

    setTimeout(() => {
      // A が画面の外に吹っ飛ぶ演出
      el.textContent = nameA;
      el.animate(
        [
          { transform:"translateX(0)",   opacity:1 },
          { transform:"translateX(80px)", opacity:0 }
        ],
        { duration:220, easing:"ease-in" }
      );

      setTimeout(() => {
        // 最後に B がドーンと勝者ポジション
        el.textContent = nameB;
        el.animate(
          [
            { transform:"scale(1)"   },
            { transform:"scale(1.25)" },
            { transform:"scale(1)"   }
          ],
          { duration:260, easing:"ease-out" }
        );
        setTimeout(() => {
          finishSelection(finalIdx, "special");
        }, 270);
      }, 230);
    }, 240);
  }, 230);
}

/* ★B が攻めてくるが A がはじき返して勝つパターン（10%） */
function playCounterFinish(el, prevIdx, finalIdx){
  const nameA = currentList[prevIdx];    // 勝者（前の人）
  const nameB = currentList[finalIdx];   // 攻めてくる次の人

  // まず A が構える
  el.textContent = nameA;
  el.animate(
    [
      { transform:"translateX(0)"   },
      { transform:"translateX(10px)" },
      { transform:"translateX(0)"   }
    ],
    { duration:220, easing:"ease-out" }
  );

  setTimeout(() => {
    // B が右側から突撃
    el.textContent = nameB;
    el.animate(
      [
        { transform:"translateX(80px)", opacity:0 },
        { transform:"translateX(0)",    opacity:1 }
      ],
      { duration:230, easing:"ease-out" }
    );

    setTimeout(() => {
      // A が反撃して B を吹っ飛ばす
      el.textContent = nameB;
      el.animate(
        [
          { transform:"translateX(0)",    opacity:1 },
          { transform:"translateX(-80px)", opacity:0 }
        ],
        { duration:220, easing:"ease-in" }
      );

      setTimeout(() => {
        // A がドヤッと中央に残る
        el.textContent = nameA;
        el.animate(
          [
            { transform:"scale(1)"   },
            { transform:"scale(1.25)" },
            { transform:"scale(1)"   }
          ],
          { duration:260, easing:"ease-out" }
        );
        setTimeout(() => {
          finishSelection(prevIdx, "special");
        }, 270);
      }, 230);
    }, 240);
  }, 230);
}

/* ★確定後の共通処理（履歴、音止め、軽い演出など） */
function finishSelection(selIdx, mode){
  const rouletteEl = document.getElementById("roulette");
  const historyEl  = document.getElementById("history");

  const selected = currentList[selIdx] || rouletteEl.textContent;

  rouletteEl.textContent = selected;
  historyEl.innerHTML += `<li>${selected}</li>`;

  if (!allowDuplicates && currentList[selIdx] !== undefined) {
    currentList.splice(selIdx, 1);
  }

  currentIndex = 0;
  spinning = false;

  if (audio) {
    audio.pause();
    audio.currentTime = 0;
  }

  // 毎回かかる基本ハイライト
  rouletteEl.classList.add("highlight");
  rollCount++;

  // 今までの軽い演出は「直球」のときだけ
  if (mode === "normal" && rollCount % 5 === 0) {
    applySpecialEffect(rouletteEl);
  }

  setTimeout(() => {
    rouletteEl.classList.remove("highlight");
  }, 1000);
}

/* 追加のちょっとした演出（直球のときだけ使う） */
function applySpecialEffect(el){
  const effect = ["bounce","explode","burn"][Math.floor(Math.random()*3)];

  if (effect === "explode") {
    el.animate(
      [
        { transform:"scale(1)",   opacity:1 },
        { transform:"scale(1.3)", opacity:0 }
      ],
      { duration:500 }
    );
  } else if (effect === "burn") {
    el.style.transition = "color .3s, background .3s";
    el.style.background = "orange";
    el.style.color      = "white";
    setTimeout(() => {
      el.style.background = "";
      el.style.color      = "";
    }, 500);
  } else { // bounce
    el.animate(
      [
        { transform:"translateY(0px)"   },
        { transform:"translateY(-10px)" },
        { transform:"translateY(0px)"   }
      ],
      { duration:300 }
    );
  }
}
</script>
</body>
</html>
