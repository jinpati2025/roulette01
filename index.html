<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>学生ルーレット + 効果音</title>
<style>
  body { font-family: sans-serif; text-align: center; background: #f4f4f4; }
  #roulette { font-size: 48px; margin: 40px 0; height: 60px; }
  button{margin:4px;padding:4px 10px;}

  .highlight {
    color: crimson;
    font-weight: bold;
    font-size: 1.3em;
    animation: shake 0.3s;
  }

  @keyframes shake {
    0%   { transform: translateX(0); }
    25%  { transform: translateX(-5px); }
    50%  { transform: translateX(5px); }
    75%  { transform: translateX(-5px); }
    100% { transform: translateX(0); }
  }
</style>
</head>
<body>
<h1>学生ルーレット + 効果音</h1>

<div id="class-buttons" class="class-buttons"></div>
<button onclick="window.open('https://docs.google.com/spreadsheets/d/1b76BPsMlb_WSWeAAEjKnDlz4TOf4OJZZA_RnXDSf4cA/edit', '_blank')">
  名簿を編集
</button>
<button id="toggle-duplicate" onclick="toggleDuplicate()">重複なし</button>

<div id="roulette">ルーレット中...</div>
<button onclick="startRoulette()">▶ スタート</button>

<div class="history">
  <h3>選ばれた学生:</h3>
  <ul id="history"></ul>
</div>

<script>
let studentsByClass = {};
let currentClass = "";
let fullList = [];       // 画面に見せる用（全員）
let remainingList = [];  // まだ当たっていない人だけ（重複なしモード用）
let allowDuplicates = false;
let spinning = false;
let currentIndex = 0;
let audio;
let rollCount = 0;

// ★テスト用：直球 / 弾き飛ばす / はじき返す を強制したいときだけ使う
// null     → 通常（70%直球・20%弾き飛ばす・10%はじき返す）
// "attack" → 毎回 弾き飛ばす
// "counter"→ 毎回 はじき返す
// "straight" → 毎回 直球
const FORCE_MODE = null;

const isGitHub = location.hostname.includes("github.io");
const dataUrl =
  "https://script.google.com/macros/s/AKfycbwXnWol3-h3-ARAUzw88NAnC7yKMILn_WzNiNrxDz-0imv3mSBoSvYw7n5BwP7r0Cxcpw/exec";
const baseUrl = isGitHub
  ? "https://jinpati2025.github.io/roulette01/"
  : "./";

const soundFiles = [
  "01_roll_basic.mp3","02_roll_impact.mp3","03_roll_shiden.mp3",
  "04_fanfare_cheer.mp3","05_fanfare_pokupoku.mp3",
  "06_voice_oujo.mp3","07_voice_doragon.mp3"
];

/* --- 名簿データ取得してクラスボタン生成 --- */
fetch(dataUrl)
  .then(res => res.json())
  .then(data => {
    console.log("名簿取得成功:", data);
    studentsByClass = data;
    const keys = Object.keys(data);
    if (keys.length) {
      currentClass  = keys[0];
      fullList      = [...data[currentClass]];
      remainingList = [...data[currentClass]];
    }
    renderClassButtons();
  })
  .catch(err => {
    console.error("名簿取得失敗:", err);
    alert("名簿が読み込めませんでした。GASの公開設定やURLを確認してください。");
  });

/* 重複あり／なし トグル */
function toggleDuplicate(){
  allowDuplicates = !allowDuplicates;
  const btn = document.getElementById("toggle-duplicate");
  btn.textContent = allowDuplicates ? "重複あり" : "重複なし";
}

/* クラスボタン生成 */
function renderClassButtons(){
  const box = document.getElementById("class-buttons");
  box.innerHTML = "";
  Object.keys(studentsByClass).forEach(k => {
    const btn = document.createElement("button");
    btn.textContent = k;
    btn.onclick = () => selectClass(k);
    box.appendChild(btn);
  });
}

/* クラス切り替え */
function selectClass(k){
  currentClass  = k;
  fullList      = [...(studentsByClass[k] || [])];
  remainingList = [...fullList];         // 新しいクラスでは全員が未当選
  currentIndex  = 0;
  document.getElementById("history").innerHTML = "";
  document.getElementById("roulette").textContent = "名前がここに表示されます";
}

/* ★ルーレット本体 */
function startRoulette(){
  if (spinning) return;
  if (!fullList.length) {
    alert("名簿がありません");
    return;
  }
  spinning = true;

  // 効果音をランダムに選択
  const sound = soundFiles[Math.floor(Math.random() * soundFiles.length)];
  audio = new Audio(baseUrl + sound);

  audio.addEventListener("loadedmetadata", () => {
    if (!fullList.length) {
      alert("名簿が空です");
      spinning = false;
      return;
    }

    // ★回転の調整（全体の回転時間・減速具合）
    const totalSteps = 40;   // ぐるぐる回る回数
    const spinTime   = 2.7;  // 全体で約 2.7秒回転（前より1.5倍くらいゆっくり）

    const baseInterval = (spinTime * 1000) / (totalSteps + 2);

    if (audio) audio.play();

    let spins = 0;

    const step = () => {
      if (spins >= totalSteps) {
        // 回転終了 → 少し「間」を置いてから結果演出へ
        setTimeout(() => {
          runResultSequence();
        }, 1200);  // 演出開始まで約1.2秒待つ
        return;
      }

      // ぐるぐる表示部分（見た目は常に fullList を回す）
      const el = document.getElementById("roulette");
      el.textContent = fullList[currentIndex];
      currentIndex = (currentIndex + 1) % fullList.length;
      spins++;

      let delay = baseInterval;
      // 減速はややゆるめに
      if (spins > totalSteps * 0.8) {
        delay *= 1.4;
      } else if (spins > totalSteps * 0.5) {
        delay *= 1.15;
      }

      setTimeout(step, delay);
    };

    step();
  });
}

/* ★結果演出の分岐（直球／弾き飛ばす／はじき返す） */
function runResultSequence(){
  const el       = document.getElementById("roulette");
  const lenFull  = fullList.length;

  if (!lenFull) {
    // 万一の保険
    finishSelection(null, "normal");
    return;
  }

  // ===== 抽選プールの決定 =====
  let pool;

  if (allowDuplicates) {
    // 重複あり：全員からランダム
    pool = fullList;
  } else {
    // 重複なし：remainingList からだけ当たる
    if (!remainingList.length) {
      // ★全員一周 → 自動リセット
      remainingList = [...fullList];
      document.getElementById("history").innerHTML = "";
    }
    pool = remainingList;
  }

  if (!pool.length) {
    finishSelection(null, "normal");
    return;
  }

  // 抽選する人（勝者候補 B）を決定（pool は remainingList または fullList）
  const selIdxInPool = Math.floor(Math.random() * pool.length);
  const nameB = pool[selIdxInPool];

  // B の「一つ前の人」を fullList から探して A にする（演出用）
  let idxInFull = fullList.indexOf(nameB);
  if (idxInFull === -1) idxInFull = 0;  // 念のため保険
  const prevFullIdx = (idxInFull - 1 + lenFull) % lenFull;
  const nameA = fullList[prevFullIdx];

  // ===== モード決定 =====
  let mode = "normal";

  if (FORCE_MODE) {
    if (FORCE_MODE === "straight") mode = "normal";
    else if (FORCE_MODE === "attack") mode = "attack";
    else if (FORCE_MODE === "counter") mode = "counter";
  } else {
    // ランダム運用（70%直球・20%弾き飛ばす・10%はじき返す）
    if (lenFull >= 2) {
      const r = Math.random();
      if (r < 0.10) {
        mode = "counter";  // 10%
      } else if (r < 0.30) {
        mode = "attack";   // 次の20%
      } else {
        mode = "normal";   // 残り70%
      }
    }
  }

  console.log("mode:", mode, "A:", nameA, "B:", nameB);

  // 3パターン共通の導入演出（A → B）
  playIntro(el, nameA, nameB, () => {
    if (mode === "normal" || lenFull < 2) {
      // 直球パターン（B が普通に当たり）
      playNormalFinish(el, nameB);
    } else if (mode === "attack") {
      // A がほぼ当たり → B が弾き飛ばして勝つ
      playAttackFinish(el, nameA, nameB);
    } else {
      // B が攻めてくるが、A がはじき返して勝つ
      playCounterFinish(el, nameA, nameB);
    }
  });
}

/* ★導入演出（Aで決まりかけ → Bも候補に見える） */
function playIntro(el, nameA, nameB, done){
  // ① A が一瞬「当たりっぽく」光る
  el.textContent = nameA;
  el.animate(
    [
      { transform:"scale(1)"   },
      { transform:"scale(1.25)" },
      { transform:"scale(1)"   }
    ],
    { duration:280, easing:"ease-out" }
  );

  setTimeout(() => {
    // ② B にもチャンスがありそうに見せる
    el.textContent = nameB;
    el.animate(
      [
        { transform:"scale(1)"   },
        { transform:"scale(1.2)" },
        { transform:"scale(1)"   }
      ],
      { duration:280, easing:"ease-out" }
    );
    setTimeout(done, 290);
  }, 290);
}

/* ★直球パターンの決定演出（軽い演出をここに集約） */
function playNormalFinish(el, selectedName){
  el.textContent = selectedName;
  el.animate(
    [
      { transform:"scale(1)"   },
      { transform:"scale(1.2)" },
      { transform:"scale(1)"   }
    ],
    { duration:240, easing:"ease-out" }
  );

  setTimeout(() => {
    finishSelection(selectedName, "normal");
  }, 250);
}

/* ★B が A を弾き飛ばして勝つパターン（小競り合い＋右にクルクル） */
function playAttackFinish(el, nameA, nameB){
  let round = 0;

  const clash = () => {
    if (round >= 2) {
      // 3回目で決着
      finalHit();
      return;
    }

    // ★B がバネのようにタメて左から突進
    el.textContent = nameB;
    el.animate(
      [
        { transform:"translateX(-110px) scale(0.9)",  opacity:0.7 },
        { transform:"translateX(   0px) scale(1.18)", opacity:1.0 },
        { transform:"translateX(  35px) scale(0.96)", opacity:1.0 },
        { transform:"translateX(   0px) scale(1.0)",  opacity:1.0 }
      ],
      { duration:380, easing:"ease-in-out" }
    );

    setTimeout(() => {
      // ★A がよろけながら耐える（右に大きく揺れる）
      el.textContent = nameA;
      el.animate(
        [
          { transform:"translateX( 20px) scale(1.0)"  },
          { transform:"translateX( 70px) scale(0.95)" },
          { transform:"translateX( 25px) scale(1.0)"  },
          { transform:"translateX(  0px) scale(1.0)"  }
        ],
        { duration:340, easing:"ease-in-out" }
      );

      round++;
      setTimeout(clash, 350);
    }, 390);
  };

  clash();

  function finalHit(){
    // ★B がさらに大きくタメて本気突進
    el.textContent = nameB;
    el.animate(
      [
        { transform:"translateX(-150px) scale(0.9)",   opacity:0.6 },
        { transform:"translateX(    0px) scale(1.25)", opacity:1.0 },
        { transform:"translateX(  70px) scale(1.05)",  opacity:1.0 },
        { transform:"translateX(    0px) scale(1.0)",  opacity:1.0 }
      ],
      { duration:420, easing:"ease-out" }
    );

    setTimeout(() => {
      // ★A が右の画面外へクルクル吹っ飛ぶ
      el.textContent = nameA;
      el.animate(
        [
          { transform:"translateX(0)       rotate(0deg)      scale(1.0)", opacity:1 },
          { transform:"translateX(620px)   rotate(1080deg)   scale(0.3)", opacity:0 }
        ],
        { duration:750, easing:"ease-in" }
      );

      setTimeout(() => {
        // ★B が左から戻ってきて中央でドン
        el.textContent = nameB;
        el.animate(
          [
            { transform:"translateX(-90px) scale(1.1)", opacity:0 },
            { transform:"translateX(  0px) scale(1.0)", opacity:1 }
          ],
          { duration:420, easing:"ease-out" }
        );

        setTimeout(() => {
          finishSelection(nameB, "special");
        }, 430);
      }, 770);
    }, 440);
  }
}

/* ★B が攻めてくるが A がはじき返して勝つパターン（小競り合い＋左にクルクル） */
function playCounterFinish(el, nameA, nameB){
  let round = 0;

  const clash = () => {
    if (round >= 2) {
      finalHit();
      return;
    }

    // ★B が右からバネのように突進
    el.textContent = nameB;
    el.animate(
      [
        { transform:"translateX(110px)  scale(0.9)",  opacity:0.7 },
        { transform:"translateX(  0px)  scale(1.18)", opacity:1.0 },
        { transform:"translateX(-35px)  scale(0.96)", opacity:1.0 },
        { transform:"translateX(  0px)  scale(1.0)",  opacity:1.0 }
      ],
      { duration:380, easing:"ease-in-out" }
    );

    setTimeout(() => {
      // ★A が左にぐっと踏ん張る
      el.textContent = nameA;
      el.animate(
        [
          { transform:"translateX(-20px) scale(1.0)"  },
          { transform:"translateX(-70px) scale(0.95)" },
          { transform:"translateX(-25px) scale(1.0)"  },
          { transform:"translateX(  0px) scale(1.0)"  }
        ],
        { duration:340, easing:"ease-in-out" }
      );

      round++;
      setTimeout(clash, 350);
    }, 390);
  };

  clash();

  function finalHit(){
    // ★A が左からカウンター気味に突進
    el.textContent = nameA;
    el.animate(
      [
        { transform:"translateX(-150px) scale(0.9)",   opacity:0.6 },
        { transform:"translateX(    0px) scale(1.25)", opacity:1.0 },
        { transform:"translateX(-70px)  scale(1.05)",  opacity:1.0 },
        { transform:"translateX(    0px) scale(1.0)",  opacity:1.0 }
      ],
      { duration:420, easing:"ease-out" }
    );

    setTimeout(() => {
      // ★B が左の画面外へクルクル吹っ飛ぶ
      el.textContent = nameB;
      el.animate(
        [
          { transform:"translateX(0)        rotate(0deg)       scale(1.0)", opacity:1 },
          { transform:"translateX(-620px)   rotate(-1080deg)   scale(0.3)",  opacity:0 }
        ],
        { duration:750, easing:"ease-in" }
      );

      setTimeout(() => {
        // ★A が右から戻ってきて中央でドヤ
        el.textContent = nameA;
        el.animate(
          [
            { transform:"translateX(90px) scale(1.1)", opacity:0 },
            { transform:"translateX( 0px) scale(1.0)", opacity:1 }
          ],
          { duration:420, easing:"ease-out" }
        );

        setTimeout(() => {
          finishSelection(nameA, "special");
        }, 430);
      }, 770);
    }, 440);
  }
}

/* ★確定後の共通処理（履歴、音止め、軽い演出など） */
function finishSelection(selectedName, mode){
  const rouletteEl = document.getElementById("roulette");
  const historyEl  = document.getElementById("history");

  if (!selectedName) {
    selectedName = rouletteEl.textContent || "";
  }

  rouletteEl.textContent = selectedName;
  historyEl.innerHTML += `<li>${selectedName}</li>`;

  // 重複なしモードなら remainingList から削除
  if (!allowDuplicates && selectedName) {
    const idx = remainingList.indexOf(selectedName);
    if (idx !== -1) remainingList.splice(idx, 1);
  }

  currentIndex = 0;
  spinning = false;

  if (audio) {
    audio.pause();
    audio.currentTime = 0;
  }

  // ★全員出たら自動リセット（重複なしモードのときだけ）
  if (!allowDuplicates && !remainingList.length && fullList.length) {
    remainingList = [...fullList];
    document.getElementById("history").innerHTML = "";
  }

  // 毎回かかる基本ハイライト
  rouletteEl.classList.add("highlight");
  rollCount++;

  // ちょっとした追加演出は直球のときだけ
  if (mode === "normal" && rollCount % 5 === 0) {
    applySpecialEffect(rouletteEl);
  }

  setTimeout(() => {
    rouletteEl.classList.remove("highlight");
  }, 1000);
}

/* 追加のちょっとした演出（直球のときだけ使う） */
function applySpecialEffect(el){
  const effect = ["bounce","explode","burn"][Math.floor(Math.random()*3)];

  if (effect === "explode") {
    el.animate(
      [
        { transform:"scale(1)",   opacity:1 },
        { transform:"scale(1.3)", opacity:0 }
      ],
      { duration:500 }
    );
  } else if (effect === "burn") {
    el.style.transition = "color .3s, background .3s";
    el.style.background = "orange";
    el.style.color      = "white";
    setTimeout(() => {
      el.style.background = "";
      el.style.color      = "";
    }, 500);
  } else { // bounce
    el.animate(
      [
        { transform:"translateY(0px)"   },
        { transform:"translateY(-10px)" },
        { transform:"translateY(0px)"   }
      ],
      { duration:300 }
    );
  }
}
</script>
</body>
</html>
