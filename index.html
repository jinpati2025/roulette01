<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>学生ルーレット + 効果音</title>
<style>
  body { font-family: sans-serif; text-align: center; background: #f4f4f4; }
  #roulette { font-size: 48px; margin: 40px 0; height: 60px; }
  button{margin:4px;padding:4px 10px;}

  .highlight {
    color: crimson;
    font-weight: bold;
    font-size: 1.3em;
    animation: shake 0.3s;
  }

  @keyframes shake {
    0%   { transform: translateX(0); }
    25%  { transform: translateX(-5px); }
    50%  { transform: translateX(5px); }
    75%  { transform: translateX(-5px); }
    100% { transform: translateX(0); }
  }
</style>
</head>
<body>
<h1>学生ルーレット + 効果音</h1>

<div id="class-buttons" class="class-buttons"></div>
<button onclick="window.open('https://docs.google.com/spreadsheets/d/1b76BPsMlb_WSWeAAEjKnDlz4TOf4OJZZA_RnXDSf4cA/edit', '_blank')">
  名簿を編集
</button>
<button id="toggle-duplicate" onclick="toggleDuplicate()">重複なし</button>

<div id="roulette">ルーレット中...</div>
<button onclick="startRoulette()">▶ スタート</button>

<div class="history">
  <h3>選ばれた学生:</h3>
  <ul id="history"></ul>
</div>

<script>
let studentsByClass = {};
let currentClass = "";
let currentList = [];
let allowDuplicates = false;
let spinning = false;
let currentIndex = 0;
let audio;
let rollCount = 0;

// ★テスト用：ここに "attack" / "counter" / "straight" を入れるとその演出だけになる
// 本番運用は null のままにしてください
const FORCE_MODE = null;

const isGitHub = location.hostname.includes("github.io");
const dataUrl =
  "https://script.google.com/macros/s/AKfycbwXnWol3-h3-ARAUzw88NAnC7yKMILn_WzNiNrxDz-0imv3mSBoSvYw7n5BwP7r0Cxcpw/exec";
const baseUrl = isGitHub
  ? "https://jinpati2025.github.io/roulette01/"
  : "./";

const soundFiles = [
  "01_roll_basic.mp3","02_roll_impact.mp3","03_roll_shiden.mp3",
  "04_fanfare_cheer.mp3","05_fanfare_pokupoku.mp3",
  "06_voice_oujo.mp3","07_voice_doragon.mp3"
];

/* --- 名簿データ取得してクラスボタン生成 --- */
fetch(dataUrl)
  .then(res => res.json())
  .then(data => {
    console.log("名簿取得成功:", data);
    studentsByClass = data;
    const keys = Object.keys(data);
    if (keys.length) {
      currentClass = keys[0];
      currentList  = [...data[currentClass]];
    }
    renderClassButtons();
  })
  .catch(err => {
    console.error("名簿取得失敗:", err);
    alert("名簿が読み込めませんでした。GASの公開設定やURLを確認してください。");
  });

/* 重複あり／なし トグル */
function toggleDuplicate(){
  allowDuplicates = !allowDuplicates;
  const btn = document.getElementById("toggle-duplicate");
  btn.textContent = allowDuplicates ? "重複あり" : "重複なし";
}

/* クラスボタン生成 */
function renderClassButtons(){
  const box = document.getElementById("class-buttons");
  box.innerHTML = "";
  Object.keys(studentsByClass).forEach(k => {
    const btn = document.createElement("button");
    btn.textContent = k;
    btn.onclick = () => selectClass(k);
    box.appendChild(btn);
  });
}

/* クラス切り替え */
function selectClass(k){
  currentClass = k;
  currentList  = [...(studentsByClass[k] || [])];
  document.getElementById("history").innerHTML = "";
  document.getElementById("roulette").textContent = "名前がここに表示されます";
}

/* ★ルーレット本体 */
function startRoulette(){
  if (spinning) return;
  if (!currentList.length) {
    alert("名簿がありません");
    return;
  }
  spinning = true;

  // 効果音をランダムに選択
  const sound = soundFiles[Math.floor(Math.random() * soundFiles.length)];
  audio = new Audio(baseUrl + sound);

  audio.addEventListener("loadedmetadata", () => {
    if (!currentList.length) {
      alert("名簿が空です");
      spinning = false;
      return;
    }

    // ★最終的に当たる位置をランダムに決める
    const finalIndex = Math.floor(Math.random() * currentList.length);

    // ★回転の調整
    const totalSteps = 40;   // 少し多めに回す
    const spinTime   = 1.8;  // 約1.8秒回転

    const baseInterval = (spinTime * 1000) / (totalSteps + 2);

    if (audio) audio.play();

    let spins = 0;

    const step = () => {
      if (spins >= totalSteps) {
        // 回転終了 → 少し「間」を置いてから結果演出へ
        setTimeout(() => {
          runResultSequence(finalIndex);
        }, 250);
        return;
      }

      // ぐるぐる表示部分
      const el = document.getElementById("roulette");
      el.textContent = currentList[currentIndex];
      currentIndex = (currentIndex + 1) % currentList.length;
      spins++;

      let delay = baseInterval;
      // 減速はややゆるめ
      if (spins > totalSteps * 0.8) {
        delay *= 1.4;
      } else if (spins > totalSteps * 0.5) {
        delay *= 1.15;
      }

      setTimeout(step, delay);
    };

    step();
  });
}

/* ★結果演出の分岐（直球／弾き飛ばす／はじき返す） */
function runResultSequence(finalIndex){
  const el  = document.getElementById("roulette");
  const len = currentList.length;

  if (!len) {
    finishSelection(finalIndex, "normal");
    return;
  }

  // 前の人（A）と当たりの人（B）を決定
  const prevIdx = (finalIndex - 1 + len) % len;  // 前の人
  const nameA   = currentList[prevIdx];
  const nameB   = currentList[finalIndex];

  // モード決定
  let mode = "normal";

  if (FORCE_MODE) {
    // テスト用：強制モード
    if (FORCE_MODE === "straight") {
      mode = "normal";
    } else if (FORCE_MODE === "attack") {
      mode = "attack";
    } else if (FORCE_MODE === "counter") {
      mode = "counter";
    }
  } else {
    // ランダム運用（70% 直球、20% 弾き飛ばす、10% はじき返す）
    if (len >= 2) {
      const r = Math.random();
      if (r < 0.10) {
        mode = "counter";  // 10%
      } else if (r < 0.30) {
        mode = "attack";   // 次の 20%
      } else {
        mode = "normal";   // 残り 70%
      }
    }
  }

  console.log("mode:", mode, "A:", nameA, "B:", nameB);

  // まずは 3パターン共通の導入演出（A → B）
  playIntro(el, nameA, nameB, () => {
    if (mode === "normal" || len < 2) {
      // 直球パターン
      playNormalFinish(el, finalIndex);
    } else if (mode === "attack") {
      // 前の人 A を弾き飛ばして B が勝つ
      playAttackFinish(el, prevIdx, finalIndex);
    } else { // counter
      // B が攻めてくるが、A がはじき返す
      playCounterFinish(el, prevIdx, finalIndex);
    }
  });
}

/* ★導入演出（Aで決まりかけ → Bも候補に見える） */
function playIntro(el, nameA, nameB, done){
  // ① A が一瞬「当たりっぽく」光る
  el.textContent = nameA;
  el.animate(
    [
      { transform:"scale(1)"   },
      { transform:"scale(1.25)" },
      { transform:"scale(1)"   }
    ],
    { duration:280, easing:"ease-out" }
  );

  setTimeout(() => {
    // ② B にもチャンスがありそうに見せる
    el.textContent = nameB;
    el.animate(
      [
        { transform:"scale(1)"   },
        { transform:"scale(1.2)" },
        { transform:"scale(1)"   }
      ],
      { duration:280, easing:"ease-out" }
    );
    setTimeout(done, 290);
  }, 290);
}

/* ★直球パターンの決定演出（軽い演出をここに集約） */
function playNormalFinish(el, selIdx){
  const selected = currentList[selIdx];

  el.textContent = selected;
  el.animate(
    [
      { transform:"scale(1)"   },
      { transform:"scale(1.2)" },
      { transform:"scale(1)"   }
    ],
    { duration:240, easing:"ease-out" }
  );

  setTimeout(() => {
    finishSelection(selIdx, "normal");
  }, 250);
}

/* ★B が A を弾き飛ばして勝つパターン
   ばねでタメて 2回小競り合い → 3回目で A が右にクルクル吹っ飛ぶ */
function playAttackFinish(el, prevIdx, finalIdx){
  const nameA = currentList[prevIdx];    // ほぼ当たりだった前の人（負け役）
  const nameB = currentList[finalIdx];   // 本当の当たり（勝ち役）

  let round = 0;

  const clash = () => {
    if (round >= 2) {
      // 3回目は決着に入る
      finalHit();
      return;
    }

    // ★B がバネのようにタメて突進（横幅広め）
    el.textContent = nameB;
    el.animate(
      [
        { transform:"translateX(-110px) scale(0.9)",  opacity:0.7 }, // タメ
        { transform:"translateX(   0px) scale(1.18)", opacity:1.0 }, // 突進
        { transform:"translateX(  35px) scale(0.96)", opacity:1.0 }, // 押し込み
        { transform:"translateX(   0px) scale(1.0)",  opacity:1.0 }  // 戻る
      ],
      { duration:380, easing:"ease-in-out" }
    );

    setTimeout(() => {
      // ★A がよろけながら耐える（横ブレ大きめ）
      el.textContent = nameA;
      el.animate(
        [
          { transform:"translateX( 20px) scale(1.0)"  },
          { transform:"translateX( 70px) scale(0.95)" },
          { transform:"translateX( 25px) scale(1.0)"  },
          { transform:"translateX(  0px) scale(1.0)"  }
        ],
        { duration:340, easing:"ease-in-out" }
      );

      round++;
      setTimeout(clash, 350);
    }, 390);
  };

  clash();

  // ★3回目：本気でぶつかって A が吹っ飛ぶ
  function finalHit(){
    // B が大きくタメて突進（さらに横幅アップ）
    el.textContent = nameB;
    el.animate(
      [
        { transform:"translateX(-150px) scale(0.9)",   opacity:0.6 },
        { transform:"translateX(    0px) scale(1.25)", opacity:1.0 },
        { transform:"translateX(  70px) scale(1.05)",  opacity:1.0 },
        { transform:"translateX(    0px) scale(1.0)",  opacity:1.0 }
      ],
      { duration:420, easing:"ease-out" }
    );

    setTimeout(() => {
      // A が右にクルクル吹っ飛ぶ（かなり外まで）
      el.textContent = nameA;
      el.animate(
        [
          { transform:"translateX(0)        rotate(0deg)      scale(1.0)", opacity:1 },
          { transform:"translateX(620px)    rotate(1080deg)   scale(0.3)",  opacity:0 }
        ],
        { duration:750, easing:"ease-in" }
      );

      setTimeout(() => {
        // B が中央にドーン
        el.textContent = nameB;
        el.animate(
          [
            { transform:"translateX(-90px) scale(1.1)", opacity:0 },
            { transform:"translateX(  0px) scale(1.0)", opacity:1 }
          ],
          { duration:420, easing:"ease-out" }
        );

        setTimeout(() => {
          finishSelection(finalIdx, "special");
        }, 430);
      }, 770);
    }, 440);
  }
}

/* ★B が攻めてくるが A がはじき返して勝つパターン
   ばねでタメて 2回小競り合い → 3回目で B が左にクルクル吹っ飛ぶ */
function playCounterFinish(el, prevIdx, finalIdx){
  const nameA = currentList[prevIdx];    // 勝者（前の人）
  const nameB = currentList[finalIdx];   // 攻めてくる次の人（負け役）

  let round = 0;

  const clash = () => {
    if (round >= 2) {
      // 3回目で決着
      finalHit();
      return;
    }

    // ★B が右からバネのように突進（横幅広め）
    el.textContent = nameB;
    el.animate(
      [
        { transform:"translateX(110px)  scale(0.9)",  opacity:0.7 },
        { transform:"translateX(  0px)  scale(1.18)", opacity:1.0 },
        { transform:"translateX(-35px)  scale(0.96)", opacity:1.0 },
        { transform:"translateX(  0px)  scale(1.0)",  opacity:1.0 }
      ],
      { duration:380, easing:"ease-in-out" }
    );

    setTimeout(() => {
      // ★A がぐっと踏ん張る（横ブレ大きめ）
      el.textContent = nameA;
      el.animate(
        [
          { transform:"translateX(-20px) scale(1.0)"  },
          { transform:"translateX(-70px) scale(0.95)" },
          { transform:"translateX(-25px) scale(1.0)"  },
          { transform:"translateX(  0px) scale(1.0)"  }
        ],
        { duration:340, easing:"ease-in-out" }
      );

      round++;
      setTimeout(clash, 350);
    }, 390);
  };

  clash();

  // ★3回目：A のカウンターで B が吹っ飛ぶ
  function finalHit(){
    // A が左からカウンター気味に前進
    el.textContent = nameA;
    el.animate(
      [
        { transform:"translateX(-150px) scale(0.9)",   opacity:0.6 },
        { transform:"translateX(    0px) scale(1.25)", opacity:1.0 },
        { transform:"translateX(-70px) scale(1.05)",   opacity:1.0 },
        { transform:"translateX(    0px) scale(1.0)",  opacity:1.0 }
      ],
      { duration:420, easing:"ease-out" }
    );

    setTimeout(() => {
      // B が左にクルクル吹っ飛ぶ（弾き飛ばすと反対側）
      el.textContent = nameB;
      el.animate(
        [
          { transform:"translateX(0)         rotate(0deg)       scale(1.0)", opacity:1 },
          { transform:"translateX(-620px)    rotate(-1080deg)   scale(0.3)",  opacity:0 }
        ],
        { duration:750, easing:"ease-in" }
      );

      setTimeout(() => {
        // A が中央にドヤッと残る
        el.textContent = nameA;
        el.animate(
          [
            { transform:"translateX(90px) scale(1.1)", opacity:0 },
            { transform:"translateX( 0px) scale(1.0)", opacity:1 }
          ],
          { duration:420, easing:"ease-out" }
        );

        setTimeout(() => {
          finishSelection(prevIdx, "special");
        }, 430);
      }, 770);
    }, 440);
  }
}

/* ★確定後の共通処理（履歴、音止め、軽い演出など） */
function finishSelection(selIdx, mode){
  const rouletteEl = document.getElementById("roulette");
  const historyEl  = document.getElementById("history");

  const selected = currentList[selIdx] || rouletteEl.textContent;

  rouletteEl.textContent = selected;
  historyEl.innerHTML += `<li>${selected}</li>`;

  if (!allowDuplicates && currentList[selIdx] !== undefined) {
    currentList.splice(selIdx, 1);
  }

  currentIndex = 0;
  spinning = false;

  if (audio) {
    audio.pause();
    audio.currentTime = 0;
  }

  // 毎回かかる基本ハイライト
  rouletteEl.classList.add("highlight");
  rollCount++;

  // 今までの軽い演出は「直球」のときだけ
  if (mode === "normal" && rollCount % 5 === 0) {
    applySpecialEffect(rouletteEl);
  }

  setTimeout(() => {
    rouletteEl.classList.remove("highlight");
  }, 1000);
}

/* 追加のちょっとした演出（直球のときだけ使う） */
function applySpecialEffect(el){
  const effect = ["bounce","explode","burn"][Math.floor(Math.random()*3)];

  if (effect === "explode") {
    el.animate(
      [
        { transform:"scale(1)",   opacity:1 },
        { transform:"scale(1.3)", opacity:0 }
      ],
      { duration:500 }
    );
  } else if (effect === "burn") {
    el.style.transition = "color .3s, background .3s";
    el.style.background = "orange";
    el.style.color      = "white";
    setTimeout(() => {
      el.style.background = "";
      el.style.color      = "";
    }, 500);
  } else { // bounce
    el.animate(
      [
        { transform:"translateY(0px)"   },
        { transform:"translateY(-10px)" },
        { transform:"translateY(0px)"   }
      ],
      { duration:300 }
    );
  }
}
</script>
</body>
</html>
